import numpy as np
from scipy.optimize import minimize
import csv
import matplotlib.pyplot as plt
import os
import datetime

# Ustvari nov folder z unikatnim imenom 
def create_unique_folder(base_name="results"):
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    folder_name = f"{base_name}_{timestamp}"
    os.makedirs(folder_name, exist_ok=True)
    return folder_name

# Prebere CSV file in povpreči pielske vrednosti za vsako razdaljo 
def read_csv(file_name):
    distances = []
    pixel_data = []

    with open(file_name, mode='r') as file:
        csv_reader = csv.reader(file)
        next(csv_reader)  # Skip header
        for row in csv_reader:
            distances.append(float(row[0]))
            pixels = [float(px) for px in row[1:]]
            pixel_data.append(np.mean(pixels))  # Uporabi povprečno pixelsko vrednost 

    return np.array(distances), np.array(pixel_data)

# Formule za izračun višine 
def calculate_height(px, f0, D, sensorY, f):
    cameraY = 1080  # sensor vertical resolution
    b = f

    def calcH(b):
        fi = np.arctan(px * (sensorY / 2) / (cameraY / 2) / b)
        h = D / np.tan(f0 - fi)
        return h, fi  # Vrne h in fi kot tuple
    
    h, fi = calcH(b)
    return h

# Funkcija za pretvorbo piklelskih vrednosti v razdaljo,  uporabo parametrov 
def px2d(px, f0, f, Y, D):
    heights = calculate_height(px, f0, D, Y, f)
    return heights

# Definira funkcijo napake 
def error_function(params, measured_distances, pixel_data):
    f0 = params[0]
    f = params[1]
    Y = params[2]
    D = params[3]


    calculated_distances = px2d(pixel_data, f0, f, Y, D)
    total_error = np.sum(np.sqrt((calculated_distances-measured_distances)**2))     # SAE
    #total_error = np.sum((calculated_distances-measured_distances)**2)     # SEE

    # for D_measured, px in zip(measured_distances, pixel_data):
    #     estimated_distance = px2d(px, f0, f, Y, D)
    #     error = np.abs(estimated_distance - D_measured)
    #     total_error += np.sum(error**2)  # Sum of squared errors
    #     pass

    return total_error

# Glavni del kode
if __name__ == "__main__":
    input_file = "distances_and_pixels_FULL_RANGE_Final.csv"  
    measured_distances, pixel_data = read_csv(input_file)
    measured_distances += 122
    
    # Začetni ugib za parametre [f0, f, Y, D]
    initial_guess = [30, 3.67, 3.6, 50] 

    # Ustvari unikaten folder za shranjevanje rezultatov
    result_folder = create_unique_folder()

    # Zaženi optimizacijo
    res = minimize(error_function, initial_guess, args=(measured_distances, pixel_data), method='nelder-mead', options={'xatol': 1e-8, 'disp': True})
    
    # Prikaži pomembnosti optimizacijskega procesa 
    optimization_result_str = (f"Optimization terminated successfully.\n"
                               f"Current function value: {res.fun:.6f}\n"
                               f"Iterations: {res.nit}\n"
                               f"Function evaluations: {res.nfev}\n"
                               f"Optimization results:\n"
                               f"f0: {res.x[0]:.3f}\n"
                               f"f: {res.x[1]:.3f}\n"
                               f"Y: {res.x[2]:.3f}\n"
                               f"D: {res.x[3]:.3f}\n")

    print(optimization_result_str)

    # Save the initial guess values and optimization results to a file
    with open(os.path.join(result_folder, "optimization_results.txt"), "w") as file:
        file.write("Initial guess values:\n")
        file.write(f"f0: {initial_guess[0]:.3f}\n")
        file.write(f"f: {initial_guess[1]:.3f}\n")
        file.write(f"Y: {initial_guess[2]:.3f}\n")
        file.write(f"D: {initial_guess[3]:.3f}\n\n")
        file.write(optimization_result_str)

    # Izris grafa
    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 12))

    # Risanje izračunanih višin
    calculated_heights = np.array([calculate_height(px, res.x[0], res.x[3], res.x[2], res.x[1]) for px in pixel_data])
    ax1.plot(measured_distances, calculated_heights, label='Calculated Heights')
    ax1.set_xlabel('Measured Distances')
    ax1.set_ylabel('Calculated Heights')
    ax1.legend()

    # Prikaz izmerjenih razdalj v primerjavi z ocenjenimi razdaljami
    estimated_distances = np.array([px2d(px, res.x[0], res.x[1], res.x[2], res.x[3]) for px in pixel_data])
    ax2.plot(measured_distances, estimated_distances, label='Estimated Distances', linestyle='--')
    ax2.set_xlabel('Measured Distances')
    ax2.set_ylabel('Estimated Distances')
    ax2.legend()

    # Napake pri risanju
    errors = np.array([px2d(px, res.x[0], res.x[1], res.x[2], res.x[3]) - D_measured for px, D_measured in zip(pixel_data, measured_distances)])
    ax3.plot(measured_distances, errors, label='Errors', linestyle='-', marker='o', color='red')
    ax3.set_xlabel('Measured Distances')
    ax3.set_ylabel('Errors (Estimated - Measured)')
    ax3.legend()

    plt.tight_layout()

    # Shrani grafe v mapo z rezultati
    fig.savefig(os.path.join(result_folder, "results_plot.png"))

    plt.show()